__version__ = '20070503'
__doc__="""
Introduction
============

Python module for reading and writing GRIB edition 2 (GRIB2) files
(U{download<http://www.cdc.noaa.gov/people/jeffrey.s.whitaker/python/grib2/pygrib2-%(__version__)s.tar.gz>}). 
GRIB2 is the second version of the World Meterological Organization
(WMO) standard for distributing gridded data. The standard is
outlined in U{FM92 GRIB Edition 2, Code Form and Tables
<http://www.wmo.ch/web/www/DPS/grib-2.html>}. Includes a python
programmer interface for reading/writing GRIB2 grids as well as a command-line
utility (rdgrib) much like Wesley Ebisuzaki's
U{wgrib<http://www.cpc.ncep.noaa.gov/products/wesley/wgrib.html>}. 
This package can't read GRIB edition 1 files directly, but these files 
can be converted to GRIB2 using U{cnvgrib<http://www.nco.ncep.noaa.gov/pmb/codes/GRIB2/>}. 

Required
========

- U{Python<http://python.org>} 2.3 or higher.  
- U{numpy<http://sourceforge.net/project/showfiles.php?group_id=1369>}
  N-dimensional array object for python.  If numpy isn't installed,
  an attempt will be made to use it's predecesor, Numeric, instead.
- U{pyproj<http://code.google.com/p/pyproj/>} Python interface to 
  U{PROJ.4<http://proj.maptools.org>} library for cartographic transformations.
  U{PROJ.4<http://proj.maptools.org>} library must be installed first.

Recommended
===========

- U{Jasper<http://www.ece.uvic.ca/~mdadams/jasper>} library. This library
  is a C implementation of the JPEG-2000 Part-1 standard (ISO/IEC 15444-1).
  Required for JPEG2000 encoding support.
- U{PNG<http://www.libpng.org/pub/png/libpng.html>} library. This library
  is a C implementation of the Portable Network Graphics
  (PNG) image compression format. It's probably already on your system.
  Required for PNG encoding support.
- U{zlib<http://www.gzip.org/zlib/>} compression library.
  It's almost certainly already on your system.
  May be required for PNG encoding support.

Installation
============

 - set the environment variables C{$JASPER_DIR}, C{$PNG_DIR} and 
 C{$ZLIB_DIR} so that the include files and libraries for jasper,
 png and zlib will be found.  For example, the include files for 
 jasper should be found in C{$JASPER_DIR/include}, and the jasper
 library should be found in C{$JASPER_DIR/lib}. If C{$JASPER_DIR}
 is not set, then the module will be built without JPEG2000 support.
 If C{$PNG_DIR} is not set, the module will be built without PNG support.

 - Run 'python setup.py install', as root if necessary.


Example usage
=============

 - invoke the python interpreter, import the package::
    >> python
    Python 2.3.4 (#1, Aug 27 2004, 17:22:27) 
    [GCC 3.3 20030304 (Apple Computer, Inc. build 1666)] on darwin
    Type "help", "copyright", "credits" or "license" for more information.
    >>> from grib2 import Grib2Decode
 - open a GRIB2 file, create a Grib2Decode class instance::
    >>> grb = Grib2Decode('sampledata/gfs.grb')  
 - print an inventory of the file::
    >>> print grb 
    :1:1:Geopotential height [gpm]:100000 Pa (Isobaric surface):72 Hour Forecast initialized 2004120912:Latitude/longitude:Unperturbed high-resolution control forecast member 0 of 10:
    :2:1:Geopotential height [gpm]:97500 Pa (Isobaric surface):72 Hour Forecast initialized 2004120912:Latitude/longitude:Unperturbed high-resolution control forecast member 0 of 10:
    :3:1:Geopotential height [gpm]:95000 Pa (Isobaric surface):72 Hour Forecast initialized 2004120912:Latitude/longitude:Unperturbed high-resolution control forecast member 0 of 10:
  
       .....

 - find records with "Geopotential height" and "Isobaric surface":: 
    >>> recs = grb.search(['Geopotential height \[gpm\]','Isobaric surface'])
 - extract the data for those records and write to a binary file::
    >>> data = grb.getflds(recs)
    >>> data.tofile('hgt.bin')
 - get the latitudes and longitudes for the 1st requested record::
    >>> lats, lons = grb.getlatlon(*recs[0])
 - write lats/lons to another binary file::
    >>> fileout = open('latlon.bin','wb')
    >>> fileout.write(lats.tostring()); fileout.write(lons.tostring())
    >>> fileout.close()
 - close the GRIB2 file::
    >>> grb.close()

 - To do the same thing with the rdgrib command line utility::

  >> rdgrib sampledata/gfs.grb
  >> rdgrib -p 'Geopotential height \[gpm\]','Isobaric surface' -o hgt.bin sampledata/gfs.grb
  >> rdgrib -d 1 --dumplatlons -o latlon.bin sampledata/gfs.grb

Documentation
=============

 - see L{Grib2Decode}, L{Grib2Encode} for python API documentation.
 - type C{rdgrib -h} for help on command line utility.
  
Links
=====

 - U{wgrib2<http://www.cpc.ncep.noaa.gov/products/wesley/wgrib2/>}
 - U{NCEP GRIB2 C and FORTRAN libraries
   <http://www.nco.ncep.noaa.gov/pmb/codes/GRIB2/>}. This package uses
   C routines from g2clib.  
 - U{ECMWF gribAPI<http://www.ecmwf.int/products/data/software/grib2.html>}
 - U{MDL GRIB2 Decoder<http://weather.gov/mdl/iwt/grib2/decoder.htm>}
 - U{Pyrex<http://nz.cosc.canterbury.ac.nz/~greg/python/Pyrex/>}
 (used to create python interface to g2clib and proj4).
 - U{proj.4<http://proj.maptools.org>} (used to perform cartographic
 transformations).

Changelog
=========

 - B{20041213}: initial release. Fully supports lat/lon, gaussian, lambert
   conformal, polar stereographic and mercator grids.  Includes all
   product (section 4) tables included in the 20031105 version of the WMO
   GRIB2 U{document<http://www.wmo.ch/web/www/DPS/grib-2.html>}. Works with
   every GRIB2 file I could find - if you find one it has trouble with please
   let me know.
 - B{20041215}: Fixed to handle files with 'communications headers' at
   beginning of GRIB message.
 - B{20041217}: Added C{matchrecs} class method to find GRIB records with
   matching gdtnum, pdtnum, idsect, gdtmpl or pdtmpl values. Added example
   that reads an ETA grid and plots it with U{Matplotlib<http://matplotlib.sf.net/>}.
 - B{20050118}: Updated C code to g2clib-1.0.2 (from 1.0.1).
 - B{20050316}: added a new class (L{Grib2Encode}) for encoding GRIB2 messages.
   Renamed Grib2 class L{Grib2Decode}. Additional options for rdgrib utility.
 - B{20050322}: bugfixes for L{Grib2Encode}.
   Added test script (test3.py) that exercises both Grib2Decode and Grib2Encode.
 - B{20050716}: Added some support for irregular grids (such as 
   ECMWF reduced gaussian grids). JPEG2000 and PNG support is now optional.
 - B{20050829}: getfld and getflds L{Grib2Decode} methods can
   now return masked arrays when there is a bitmap.
 - B{20050830}: Now displays more ensemble info in inventory.
 - B{20051121}: Now uses Numeric by default (no longer requires
   numarray).  Can easily be modified to use nummarray or Numeric by
   modifying the imports in 3 files (grib2.py, proj.py and gaussian.py).
   A new utility, gribrepack, is included for repacking a grib2 file
   with a different compression scheme.
 - B{20051125}: Updated grib2 tables to version 3 (released
   by WMO on Nov 2, 2005).
 - B{20060117}: Now uses numpy by default (instead of Numeric).
   Python 2.5 compatibility fixes.
 - B{20070130}: Fixes some bugs found by Rob Cermak.  Now
   requires pyproj be installed first (which in turn requires
   that you have the PROJ.4 C-library installed). Updated to g2clib 1.0.4.
 - B{20070428}: Fixed memory leaks with a patch provided
   by Thomas Natschlager.
 - B{20070501}: Included new parameters approved by WMO
   for operational implementation in November, 2007.
   These new parameters are used in the U{TIGGE
   <http://tigge.ecmwf.int/tigge/d/tigge/>} grib2 files, so now all TIGGE
   files should be interpreted correctly. 'Reduced' global gaussian grids
   (from ECMWF) are now expanded to full global gaussian grids automatically
   using linear interpolation.
 - B{%(__version__)s}: Now partially supports grid definition template 90 (space-view
   satellite projection). Can't yet handle case when sub-satellite point is off the
   equator and earth is specified as an oblate spheroid. Does work with EUMETSAT
   grib2 files.  Bug fix for Oblate Spheroid earth shape (major and minor
   radii are actually in km, not m).

@author: Jeffrey Whitaker.

@contact: U{Jeff Whitaker<mailto:jeffrey.s.whitaker@noaa.gov>}

@version: %(__version__)s

@copyright: copyright 2007 by Jeffrey Whitaker.

@license: Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation.
THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO
EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR
CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
""" % locals()
import g2lib
import sxn0, sxn3, sxn4
import struct
import gaussian
import string
import math

# try to use numpy
try:
    import numpy as N
    from numpy import ma
except ImportError:
# if not available, try to use Numeric.
    try:
        import Numeric as N
        import MA as ma
    except:
        raise ImportError("requires either numpy or Numeric")

import re
from tobase import tobase
from proj import Proj
import pyproj
from compression_support import *

def putieeeint(r):
    """convert a float to a IEEE format 32 bit integer"""
    ra = N.array([r],'f')
    ia = N.zeros(1,'i')
    g2lib.rtoi_ieee(ra,ia)
    return ia[0]

def getieeeint(i):
    """convert an IEEE format 32 bit integer to a float"""
    ia = N.array([i],'i')
    ra = N.zeros(1,'f')
    g2lib.itor_ieee(ia,ra)
    return ra[0]

class Grib2Decode:
    """
 Class for accessing data in a GRIB Edition 2 file.

 When a class instance is created, metadata in the GRIB2 file
 is decoded and used to set various instance variables.  Most of
 the instances variables are nested lists which 
 can be indexed by GRIB message number and field number within the message.
 For example, L{gdtmpl}[n][i] is the grid definition template for the (i+1)th
 field in the (n+1)th GRIB message in the GRIB file. Exceptions are
 the L{gribmsgs} and L{startpos} instance variables, which are normal
 lists that can be indexed by grib message number only.
 
 @ivar idsect:     data from identification section (section 1).
 See L{Grib2Encode.__init__} for details.
 @ivar gdtnum:     grid definition template number from section 3.
 @ivar gdtmpl:     grid definition templates from section 3.
 @ivar gdeflist:   optional grid definition list from section 3. 
 @ivar gdsinfo:    grid definition section information from section 3. See
 L{Grib2Encode.addgrid} for details.
 @ivar pdtmpl:     product definition templates from section 4.
 @ivar pdtnum:     product definition template number from section 4.
 @ivar coordlist:  extra vertical coordinate info from section 4.
 @ivar drtmpl:     data representation templates from section 5.
 @ivar drtnum:     data representation template number from section 5.
 @ivar ndpts:      number of data points to be unpacked (from section 5).
 @ivar bitmapflag: bit-map indicator flag from section 6.
 @ivar bitmap:     bitmap from section 6.
 @ivar pos7:       byte offset for section 7.
 @ivar numfields:  number of fields in grib message.
 @ivar numlocal:   number of local use sections in grib message.
 @ivar discipline: discipline code for grib message.
 @ivar gribfile:   grib file object.
 @ivar parameter:  parameter name (string).
 @ivar units:      parameter units (string).
 @ivar level:      string describing level information.
 @ivar leveldesc:  level description (string).
 @ivar fcsttime:   string describing forecast time.
 @ivar projection: grid definition (map projection).
 @ivar ensinfo:    ensemble member info.
 @ivar inventory:  single line summary string, formatted like this::
 
  ':n+1:i+1:parameter[units]:level(leveldesc):fcsttime:projection:ensinfo:'

 @ivar gribmsgs:   grib message (binary string).
 @ivar startpos:   starting position (in bytes) for each grib message.
    """
    def __init__(self,filename):
        """
 create a Grib2Decode class instance given a GRIB Edition 2 filename.
 
 @param filename:  a GRIB Edition 2 file.
        """
        f = open(filename,'rb')
        self.gribfile = f
        nmsg = 0
        # lgrib is a list containing length of each grib message in file.
        lgrib = []
        # loop over grib messages, read section 0, get entire grib message.
        self.discipline = []
        self.gribmsgs = []
        self.startpos = []
        while 1:
            # find next occurence of string 'GRIB' (or EOF).
            nbyte = f.tell()
            while 1:
                f.seek(nbyte)
                start = f.read(4)
                if start == '' or start == 'GRIB': break
                nbyte = nbyte + 1
            if start == '': break # at EOF
            # otherwise, start (='GRIB') contains indicator message (section 0)
            startpos = f.tell()-4
            self.startpos.append(startpos)
            f.seek(2,1)  # next two octets are reserved
            # get discipline info.
            self.discipline.append(struct.unpack('>B',f.read(1))[0])
            # check to see it's a grib edition 2 file.
            vers = struct.unpack('>B',f.read(1))[0]
            if vers != 2: 
                raise IOError, 'not a GRIB2 file (version number %d)' % vers
            lengrib = struct.unpack('>q',f.read(8))[0]
            lgrib.append(lengrib)
            # read in entire grib message.
            f.seek(startpos)
            self.gribmsgs.append(f.read(lengrib))
            # make sure the message ends with '7777'
            end = self.gribmsgs[nmsg][-4:lengrib]
            if end != '7777':
               raise IOError, 'partial GRIB message (no "7777" at end)'
            # do next message.
            nmsg=nmsg+1
        # if no grib messages found, nmsg is still 0 and it's not GRIB.
        if nmsg==0:
           raise IOError, 'not a GRIB file'
        # now for each grib message, find number of local use sections
        # and number of fields.
        self.numfields = []
        self.numlocal = []
        for n in range(nmsg):
           gribmsg = self.gribmsgs[n]
           pos = 0
           numfields = 0
           numlocal = 0
           while 1:
               if gribmsg[pos:pos+4] == 'GRIB':
                   sectnum = 0
                   lensect = 16
               elif gribmsg[pos:pos+4] == '7777':
                   break
               else:
                   lensect = struct.unpack('>i',gribmsg[pos:pos+4])[0]
                   sectnum = struct.unpack('>B',gribmsg[pos+4])[0]
                   if sectnum == 4: numfields=numfields+1
                   if sectnum == 2: numlocal=numlocal+1
               pos = pos + lensect
               #print sectnum,lensect,pos
           #print n+1,len(gribmsg),numfields,numlocal
           self.numfields.append(numfields)
           self.numlocal.append(numlocal)
        # decode each section in grib message (sections 1 and above).
        self.idsect = [] # sxn 1 
        #self.localuse = [] # sxn 2
        self.gdtnum = [] # grid defn template number from sxn 3
        self.gdtmpl = [] # grid defn template from sxn 3
        self.gdeflist = [] # optional grid definition list from sxn 3
        self.gdsinfo = [] # grid definition section info from sxn3
        self.pdtmpl = [] # product defn template from sxn 4
        self.pdtnum = [] # product defn template number from sxn 4
        self.coordlist = [] # vertical coordinate info from sxn 4
        self.drtmpl = [] # data representation template from sxn 5
        self.drtnum = [] # data representation template number from sxn 5
        self.ndpts = [] # number of data points to be unpacked (from sxn 5)
        self.bitmapflag = [] # bit-map indicator flag from sxn 6
        self.bitmap = [] # bitmap from sxn 6.
        self.pos7 = [] # byte offset for section 7.
        for n in range(nmsg):
            gribmsg = self.gribmsgs[n]
            lensect0 = 16
            # get length of section 1 and section number.
            lensect1 = struct.unpack('>i',gribmsg[lensect0:lensect0+4])[0]
            sectnum1 = struct.unpack('>B',gribmsg[lensect0+4])[0]
            #print 'sectnum1, lensect1 = ',sectnum1,lensect1
            # unpack section 1, octets 1-21 (13 parameters).  This section
            # can occur only once per grib message.
            #idsect,pos = _unpack1(gribmsg,lensect0) # python version
            idsect,pos = g2lib.unpack1(gribmsg,lensect0,N.zeros) # c version
            self.idsect.append(idsect)
            # loop over rest of sections in message.
            #localsxns = []
            gdtnums = []
            gdtmpls = []
            gdeflists = []
            gdsinfo = []
            pdtmpls = []
            coordlists = []
            pdtnums = []
            drtmpls = []
            drtnums = []
            ndptslist = []
            bitmapflags = []
            bitmaps = []
            sxn7pos = []
            while 1:
                # check to see if this is the end of the message.
                if gribmsg[pos:pos+4] == '7777': break
                lensect = struct.unpack('>i',gribmsg[pos:pos+4])[0]
                sectnum = struct.unpack('>B',gribmsg[pos+4])[0]
                # section 2, local use section.
                if sectnum == 2:  # skip
                    #localsxns.append(gribmsg[pos+5:pos+lensect-5])
                    pos = pos + lensect
                # section 3, grid definition section.
                elif sectnum == 3:
                    gds,gdtmpl,deflist,pos = g2lib.unpack3(gribmsg,pos,N.zeros)
                    gdtnums.append(gds[4])
                    gdtmpls.append(gdtmpl)
                    gdeflists.append(deflist)
                    gdsinfo.append(gds)
                # section, product definition section.
                elif sectnum == 4:
                    pdtmpl,pdtnum,coordlist,pos = g2lib.unpack4(gribmsg,pos,N.zeros)
                    pdtmpls.append(pdtmpl)
                    coordlists.append(coordlist)
                    pdtnums.append(pdtnum)
                # section 5, data representation section.
                elif sectnum == 5:
                    drtmpl,drtnum,ndpts,pos = g2lib.unpack5(gribmsg,pos,N.zeros)
                    drtmpls.append(drtmpl)
                    drtnums.append(drtnum)
                    ndptslist.append(ndpts)
                # section 6, bit-map section.
                elif sectnum == 6:
                    bitmap,bitmapflag = g2lib.unpack6(gribmsg,gds[1],pos,N.zeros)
                    #bitmapflag = struct.unpack('>B',gribmsg[pos+5])[0]
                    bitmapflags.append(bitmapflag)
                    if bitmapflag == 0:
                       bitmaps.append(bitmap.astype('b'))
                    # use last defined bitmap.
                    elif bitmapflag == 254:
                       for bitmap in bitmaps[::-1]:
                           if bitmap is not None: bitmaps.append(bitmap)
                    else:
                       bitmaps.append(None)
                    pos = pos + lensect
                # section 7, data section (nothing done here,
                # data unpacked when getfld method is invoked).
                else:
                    if sectnum != 7:
                       msg = 'unknown section = %i' % sectnum
                       raise ValueError,msg
                    sxn7pos.append(pos)
                    pos = pos + lensect
            #self.localuse.append(_repeatlast(self.numfields[n],localsxns))
            # extend by repeating last value for all remaining fields.
            self.gdtnum.append(_repeatlast(self.numfields[n],gdtnums))
            self.gdtmpl.append(_repeatlast(self.numfields[n],gdtmpls))
            self.gdeflist.append(_repeatlast(self.numfields[n],gdeflists))
            self.gdsinfo.append(_repeatlast(self.numfields[n],gdsinfo))
            self.pdtmpl.append(_repeatlast(self.numfields[n],pdtmpls))
            self.pdtnum.append(_repeatlast(self.numfields[n],pdtnums))
            self.coordlist.append(_repeatlast(self.numfields[n],coordlists))
            self.drtmpl.append(_repeatlast(self.numfields[n],drtmpls))
            self.drtnum.append(_repeatlast(self.numfields[n],drtnums))
            self.ndpts.append(_repeatlast(self.numfields[n],ndptslist))
            self.bitmapflag.append(_repeatlast(self.numfields[n],bitmapflags))
            self.bitmap.append(_repeatlast(self.numfields[n],bitmaps))
            self.pos7.append(sxn7pos)

        # set human-readable attributes.
        self.parameter = []
        self.level = []
        self.leveldesc = []
        self.units = []
        self.fcsttime = []
        self.projection = []
        self.ensinfo = []
        for n in range(len(self.gribmsgs)):
            parameters = []
            units = []
            levels = []
            levelsdesc = []
            fcsttimes = []
            projs = []
            ensinfo=[]
            for ifld in range(self.numfields[n]):
                paramname = self._getparam(n,ifld)
                if self.gdsinfo[n][ifld][2] == 0:
                    projs.append(sxn3.codetable[1][self.gdtnum[n][ifld]])
                else:
                    projs.append('Quasi-regular '+sxn3.codetable[1][self.gdtnum[n][ifld]])
                parameters.append(paramname[0])
                units.append(paramname[1])
                yyyy,mm,dd,hh,min,ss = self._getdate(n)
                if min == 0 and ss == 0:
                    date = '%0.4i'%(yyyy)+'%0.2i'%(mm)+'%0.2i'%(dd)+'%0.2i'%(hh)
                elif ss == 0 and min:
                    date = '%0.4i'%(yyyy)+'%0.2i'%(mm)+'%0.2i'%(dd)+'%0.2i'%(hh)+'%0.2i'%(min)
                else:
                    date = '%0.4i'%(yyyy)+'%0.2i'%(mm)+'%0.2i'%(dd)+'%0.2i'%(hh)+'%0.2i'%(min)+'%0.2i'%(ss)
                if self.pdtnum[n][ifld] == 8:
                   fcsttime = self._getfcsttime(n,ifld)
                   fcsttimestring = string.lstrip(repr(fcsttime[2])+' '+fcsttime[3]+' '+fcsttime[4]+' from '+repr(fcsttime[0])+' '+fcsttime[1]+' Forecast initialized '+date)
                else: 
                   try:
                       fcsttime = self._getfcsttime(n,ifld)
                       fcsttimestring = string.lstrip(repr(fcsttime[0])+' '+fcsttime[1]+' Forecast initialized '+date)
                   except:
                       fcsttimestring=""
                fcsttimes.append(fcsttimestring)
                levinfo = self._getvertlevel(n,ifld)
                if len(levinfo) > 3:
                   if levinfo[0]:
                       levs = '%g-%g '%(levinfo[0],levinfo[3])
                   else:
                       levs=''
                else:
                   if levinfo[0]:
                       levs = '%g '%levinfo[0]
                   else:
                       levs=''
                levels.append(levs+levinfo[1])
                levelsdesc.append(levinfo[2])
                if self.pdtnum[n][ifld] in [1,11]:
                    ensname,pertnum,nmembers = self._getensinfo(n,ifld)
                    ensinfo.append(ensname+' member '+repr(pertnum)+' of '+repr(nmembers))
                elif self.pdtnum[n][ifld] in [2,12]:
                    ensname,pertnum,nmembers = self._getensinfo(n,ifld)
                    ensinfo.append(ensname+' from a '+repr(nmembers)+' member ensemble')
                else:
                    ensinfo.append('')
            self.parameter.append(_repeatlast(self.numfields[n],parameters))
            self.units.append(_repeatlast(self.numfields[n],units))
            self.fcsttime.append(_repeatlast(self.numfields[n],fcsttimes))
            self.level.append(_repeatlast(self.numfields[n],levels))
            self.leveldesc.append(_repeatlast(self.numfields[n],levelsdesc))
            self.projection.append(_repeatlast(self.numfields[n],projs))
            self.ensinfo.append(_repeatlast(self.numfields[n],ensinfo))
        # inventory.
        self.inventory = []
        for n,gribmess in enumerate(self.gribmsgs):
            i = []
            for ifld in range(self.numfields[n]):
                if self.units[n][ifld]=='':
                    paramstring = self.parameter[n][ifld]
                else:
                    paramstring = self.parameter[n][ifld]+' ['+self.units[n][ifld]+']'
                fcsttimestring = self.fcsttime[n][ifld]
                if self.leveldesc[n][ifld] != '':
                    levstring = string.lstrip(self.level[n][ifld]+' ('+self.leveldesc[n][ifld]+')')
                else:
                    levstring = ''
                if self.ensinfo[n][ifld] != '':
                    i.append(':'+repr(n+1)+':'+repr(ifld+1)+':'+paramstring+':'+levstring+':'+fcsttimestring+':'+self.projection[n][ifld]+':'+self.ensinfo[n][ifld]+':')
                else:
                    i.append(':'+repr(n+1)+':'+repr(ifld+1)+':'+paramstring+':'+levstring+':'+fcsttimestring+':'+self.projection[n][ifld]+':')
            self.inventory.append(i)
        # flattened version for searching.
        self._inventory = []
        self._indices = []
        self._parameter = []
        self._level = []
        self._leveldesc = []
        self._units = []
        self._fcsttime = []
        self._projection = []
        self._ensinfo = []
        for n in range(len(self.gribmsgs)):
            for i in range(self.numfields[n]):
                self._inventory.append(self.inventory[n][i])
                self._indices.append((n,i))
                self._parameter.append(self.parameter[n][i])
                self._level.append(self.level[n][i])
                self._leveldesc.append(self.leveldesc[n][i])
                self._units.append(self.units[n][i])
                self._fcsttime.append(self.fcsttime[n][i])
                self._projection.append(self.projection[n][i])
                self._ensinfo.append(self.ensinfo[n][i])

    def search(self,patternstrings):
        """
 search for regular expression patterns in the GRIB2 inventory.
 
 @param patternstrings:  a list of strings containing regular 
 expression patterns to search for.
 
 @return: C{B{matches}}, a list containing the (grib message number,
 grib field number) tuples of the matching grids which can be used
 to unpack the desired grids using the L{getflds} class method.
        """
        if not isinstance(patternstrings,list):
            patternstrings = list(patternstrings)
        matches = range(len(self._inventory))
        for p in patternstrings:
            r = re.compile(p)
            m = matches
            matches = []
            for n in m:
                if r.search(self._inventory[n]):
                    matches.append(n)
        return [self._indices[n] for n in matches]

    def matchrecs(self,idsect=None,gdtnum=None,pdtnum=None,gdtmpl=None,pdtmpl=None):
        """
 search for records which match specified identification section,
 grid and product definition information.
 
 @param idsect: array or list with specified identification section
 (i.e. section 1) information  (default None matches all records).
 Entries equal to sys.maxint are ignored, as are missing entries. 

 @param gdtnum: scalar specified grid definition template number
 (default None matches all records).

 @param pdtnum: scalar specified product definition template number
 (default None matches all records).

 @param gdtmpl: array or list with specified grid definition template
 information (default None matches all records).
 Entries equal to sys.maxint are ignored, as are missing entries. 

 @param pdtmpl: array or list with specified product definition template
 information (default None matches all records).
 Entries equal to sys.maxint are ignored, as are missing entries.
 
 @return: C{B{matches}}, a list containing the (grib message number,
 grib field number) tuples of the matching grids which can be used
 to unpack the desired grids using the L{getflds} class method.
        """
        matches = []
        # loop over all grib records.
        for n in range(len(self.gribmsgs)):
            for i in range(self.numfields[n]):
                if gdtmpl != None:
                    gdtmpl_list = self.gdtmpl[n][i].tolist()
            # if input grid defn tmpl is longer than grib gdtmpl, skip.
            # if it is shorter, truncate the grib gdtmpl for comparison.
                    if len(gdtmpl) < len(gdtmpl_list):
                        gdtmpl_list = gdtmpl_list[0:len(gdtmpl)]
                    elif len(gdtmpl) > len(gdtmpl_list):
                        break
                if pdtmpl != None:
                    pdtmpl_list = self.pdtmpl[n][i].tolist()
            # if input product defn tmpl is longer than grib pdtmpl, skip.
            # if it is shorter, truncate the grib pdtmpl for comparison.
                    if len(pdtmpl) < len(pdtmpl_list):
                        pdtmpl_list = pdtmpl_list[0:len(pdtmpl)]
                    elif len(pdtmpl) > len(pdtmpl_list):
                        break
            # as above, for idsect.
                if idsect != None:
                    idsect_list = self.idsect[n][i].tolist()
                    if len(idsect) < len(idsect_list):
                        idsect_list = idsect_list[0:len(idsect)]
                    elif len(idsect) > len(idsect_list):
                        break
                # check for matches.
                if (gdtnum == None or self.gdtnum[n][i] == gdtnum) and \
                   (pdtnum == None or self.pdtnum[n][i] == pdtnum) and \
                   (idsect == None or \
                    N.alltrue(idsectl_list==N.where(idsectl<sys.maxint,idsectl_list,idsectl))) and \
                   (gdtmpl == None or \
                    N.alltrue(gdtmpl_list==N.where(gdtmpl<sys.maxint,gdtmpl_list,gdtmpl))) and \
                   (pdtmpl == None or \
                    N.alltrue(pdtmpl_list==N.where(pdtmpl<sys.maxint,pdtmpl_list,pdtmpl))):
                       matches.append((n,i))
        return matches

    def close(self):
        """close the Grib2Decode instance (closes the open GRIB2 file)"""
        self.gribfile.close()

    def __repr__(self):
        """print the inventory instance variable"""
        return self.print_inventory(printit=False)
        
    def print_inventory(self,show_pdt=False,show_gdt=False,show_drt=False,show_grdinfo=False,show_minmax=False,show_idsect=False,printit=True):
        """
 prints inventory, with additional optional information.
 
 @keyword show_pdt: print product definition template values (default False).
 @keyword show_gdt: print grid definition template values (default False)
 @keyword show_drt: print data representation template values (default False)
 @keyword show_idsect: print identification section (default False)
 @keyword show_gridinfo: print human-readable information on grid projection
 (default False).
 @keyword show_minmax: print min/max of data.
 @keyword printit: actually print the information (default True, if False
 a list of strings is returned).
        """
        info = []
        for n in range(len(self.gribmsgs)):
            for i in range(self.numfields[n]):
                info.append(self.inventory[n][i]+'\n')
                if i == 0 and show_idsect:
                    info.append('IDSECT (Discipline '+repr(self.discipline[n])+') = '+repr(self.idsect[n].tolist())+'\n')
                if show_gdt:
                    info.append('GDSINFO = '+repr(self.gdsinfo[n][i].tolist())+'\n')
                    info.append('GDT # '+repr(self.gdtnum[n][i])+' = '+repr(self.gdtmpl[n][i].tolist())+'\n')
                if show_pdt:
                    info.append('PDT # '+repr(self.pdtnum[n][i])+' = '+repr(self.pdtmpl[n][i].tolist())+'\n')
                if show_drt:
                    info.append('DRT # '+repr(self.drtnum[n][i])+' = '+repr(self.drtmpl[n][i].tolist())+' Bitmap Flag = '+repr(self.bitmapflag[n][i])+'\n')
                if show_minmax:
                    data = self.getfld(n,ifld=i,masked_array=False)
                    bitsofprecision = self.drtmpl[n][i][3]
                    digitsofprecision = int(math.ceil(math.log10(math.pow(2,bitsofprecision))))
                    format = "%."+repr(digitsofprecision+1)+"g"
                    if self.bitmapflag[n][i] == 0:
                        datatmp = N.compress(N.ravel(self.bitmap[n][i]),N.ravel(data))
                        datamin = format % min(N.ravel(datatmp))
                        datamax = format % max(N.ravel(datatmp))
                    elif self.drtnum[n][i] in [2,3] and self.drtmpl[n][i][6] != 0:
                        data1 = N.ravel(data)
                        missvalue = getieeeint(self.drtmpl[n][i][7])
                        datatmp = N.compress(data1!=missvalue,data1)
                        datamin = format % min(N.ravel(datatmp))
                        datamax = format % max(N.ravel(datatmp))
                    else:
                        datamin = format % min(N.ravel(data))
                        datamax = format % max(N.ravel(data))
                    info.append('Min/Max: '+datamin+'/'+datamax+'\n')
                if show_grdinfo:
                    projinfo = self.getgridinfo(n,i)
                    if projinfo:
                        info.append(self.projection[n][i]+' grid: '+repr(projinfo)+'\n')
                    else:
                        info.append(self.projection[n][i]+' grid: not yet supported\n')
        info[-1] = info[-1][:-1] # no line feed for last one
        if printit:
            print ''.join(info)
        else:
            return ''.join(info)

    def subset(self,grbout,msgnums):
        """
 write the given grib message numbers to a grib file.
 
 @param grbout: an open, writable binary file object to write GRIB data to.
 @param msgnums: an list of grib message numbers to write.
        """
        for n in msgnums:
            self.gribfile.seek(self.startpos[n])
            lengrib = self.startpos[n+1]-self.startpos[n]
            data = self.gribfile.read(lengrib)
            grbout.write(data)

    def getfld(self,n,ifld=0,fill_value=1.e30,masked_array=False,printminmax=False):
        """
 return an unpacked data grid.
 
 @param n: the grib message number (starting from 0) of the desired data grid.
 @keyword i: the field number within the specified message (default 0, or
 first field).
 @keyword fill_value: missing or masked data is filled with this value
 (default 1.e30).
 @keyword masked_array: if True, return masked array if there is bitmap
 for missing or masked data (default False).
 @keyword printmaxmin: print the min/max of the data field as it is decoded 
 (default False).
 
 @return: C{B{data}}, a float32 numpy regular or masked array
 with shape (nlats,lons) containing the request grid.
        """
        gribmsg = self.gribmsgs[n]
        gdtnum = self.gdtnum[n][ifld]
        ngrdpts = self.gdsinfo[n][ifld][1]
        gdtmpl = self.gdtmpl[n][ifld]
        drtnum = self.drtnum[n][ifld]
        drtmpl = self.drtmpl[n][ifld]
        ndpts = self.ndpts[n][ifld]
        bitmapflag = self.bitmapflag[n][ifld]
        gdsinfo = self.gdsinfo[n][ifld]
        ipos = self.pos7[n][ifld]
        if (drtnum == 40 or drtnum == 40000) and not jpeg2000_support:
            raise ValueError, 'Sorry, but the grib2 module was not compiled with support for JPEG2000 encoding'
        if (drtnum == 41 or drtnum == 40010) and not png_support:
            raise ValueError, 'Sorry, but the grib2 module was not compiled with support for PNG encoding'
        fld1=g2lib.unpack7(gribmsg,gdtnum,gdtmpl,drtnum,drtmpl,ndpts,ipos,N.zeros,printminmax=printminmax)
        # apply bitmap.
        if bitmapflag in [0,254]:
            bitmap=self.bitmap[n][ifld]
            fld = fill_value*N.ones(ngrdpts,'f')
            fld = fld.astype('f')
            N.put(fld,N.nonzero(bitmap),fld1)
            if masked_array:
                fld = ma.masked_values(fld,fill_value)
        # missing values instead of bitmap
        elif (drtnum == 3 or drtnum == 2) and drtmpl[6] != 0 and masked_array:
            fld = ma.masked_values(fld1,getieeeint(drtmpl[7])) 
        else:
            fld = fld1
        if gdtnum in [0,10,20,30,40,90] and gdsinfo[2] == 0: # rectangular grid.
            nlons = self.gdtmpl[n][ifld][7]
            nlats = self.gdtmpl[n][ifld][8]
            if masked_array:
                fld = ma.reshape(fld,(nlats,nlons))
            else:
                fld = N.reshape(fld,(nlats,nlons))
        else:
            if gdsinfo[2] and gdtnum == 40: # ECMWF 'reduced' global gaussian grid.
                nlons = 2*self.gdtmpl[n][ifld][8]
                lonsperlat = self.gdeflist[n][ifld]
                fld = g2lib._redtoreg(nlons, lonsperlat, fld1, N.zeros)
            else:
                fld = fld1
        return fld

    def getflds(self,matches,fill_value=1.e30,masked_array=False,printminmax=False):
        """
 return unpacked data grids.
 
 @param matches: a list of (grib message number, grib field number) tuples
 describing the desired data grids (usually a list returned 
 by the L{search} or L{matchrecs} class methods).
 @keyword fill_value: missing or masked data is filled with this value
 (default 1.e30).
 @keyword masked_array: if True, return masked array if there is bitmap
 for missing or masked data (default False).
 @keyword printmaxmin: print the min/max of the data field as it is decoded 
 (default False).
 
 @return: C{B{data}}, a float32 numpy regular or masked array
 containing the requested grids. The shape is
 (ngrids, nlats, nlons), where ngrids == len(matches).
        """
        nmsg = matches[0][0]
        ifld = matches[0][1]
        gdtnum = self.gdtnum[nmsg][ifld]
        gdsinfo = self.gdsinfo[nmsg][ifld]
        npts = self.gdsinfo[nmsg][ifld][1]
        if gdtnum in [0,10,20,30,40] and gdsinfo[2] == 0: # rectangular grid.
            nx = self.gdtmpl[nmsg][ifld][7]
            ny = self.gdtmpl[nmsg][ifld][8]
            data = N.zeros((len(matches),ny,nx),'f')
            if masked_array:
                data = ma.zeros((len(matches),ny,nx),'f')
            else:
                data = N.zeros((len(matches),ny,nx),'f')
        else:
            if masked_array:
                data = ma.zeros((len(matches),npts),'f')
            else:
                data = N.zeros((len(matches),npts),'f')
        for n,i in enumerate(matches):
            nmsg = i[0]; ifld = i[1]
            # check to see horizontal grid the same for each request
            if self.gdtnum[nmsg][ifld] != gdtnum:
                raise ValueError, 'data must all be on the same grid'
            if gdsinfo[1] != npts:
                raise ValueError, 'grids must all be same size'
            fld = self.getfld(nmsg,ifld=ifld,fill_value=fill_value,masked_array=masked_array,printminmax=printminmax)
            data[n] = fld
        return data

    def getlatlon(self,n,ifld=0):
        """
 return lats,lons (in degrees) for desired data grid.
 currently can handle reg. lat/lon, global gaussian, mercator, stereographic
 and lambert conformal grids.

 @param n: the grib message number (starting from 0) of the grid.
 @keyword i: the field number within the specified message (default 0, or
 first field).
 
 @return: C{B{lats},B{lons}}, float32 numpy arrays with shape (nlats,nlons)
 containing latitudes and longitudes of grid (in degrees).
        """
        # get projinfo dict 
        projinfo = self.getgridinfo(n,ifld=0)
        if projinfo.has_key('projparams'):
            projparams = projinfo['projparams']
        nonreggrid = self.gdsinfo[n][ifld][2]
        if nonreggrid and self.gdtnum[n][ifld] != 40:
            print 'non regular grid - cannot compute lons and lats'
            return False, False
        if self.gdtnum[n][ifld] == 0: # regular lat/lon grid
            lat1, lon1 = projinfo['lat/lon first grid pt']
            lat2, lon2 = projinfo['lat/lon last grid pt']
            delon = projinfo['dlon']
            delat = projinfo['dlat']
            lats = N.arange(lat1,lat2+delat,delat)
            lons = N.arange(lon1,lon2+delon,delon)
            lons,lats = _meshgrid(lons,lats) # make 2-d arrays.
        elif self.gdtnum[n][ifld] == 40: # gaussian grid (only works for global!)
            lat1, lon1 = projinfo['lat/lon first grid pt']
            lat2, lon2 = projinfo['lat/lon last grid pt']
            nlats = projinfo['nlats']
            if nonreggrid: # ECMWF 'reduced' gaussian grid.
                nlons = 2*nlats
                delon = 360./nlons
            else:
                delon = projinfo['dlon']
                nlons = projinfo['nlons']
            if lon1 > lon2:
                delon = -delon
            lons = N.arange(lon1,lon2+delon,delon)
            # compute gaussian lats (north to south)
            lats = gaussian.lats(nlats)
            if lat1 < lat2:  # reverse them if necessary
                lats = lats[::-1]
            lons,lats = _meshgrid(lons,lats) # make 2-d arrays
        elif self.gdtnum[n][ifld] in [10,20,30]: # mercator, lambert conformal,stereographic
            nx = projinfo['nx']
            ny = projinfo['ny']
            dx = projinfo['dx']
            dy = projinfo['dy']
            lat1, lon1 = projinfo['lat/lon first grid pt']
            if self.gdtnum[n][ifld] == 10:
                lat2, lon2 = projinfo['lat/lon last grid pt']
                pj = Proj(projparams,lon1,lat1,lon2,lat2)
            else:
                pj = Proj(projparams,lon1,lat1,(nx-1)*dx,(ny-1)*dy,urcrnrislatlon=False)
            lons, lats = pj.makegrid(nx,ny)
        elif self.gdtnum[n][ifld] == 90: # satellite projection.
            nx = projinfo['nx']
            ny = projinfo['ny']
            pj = pyproj.Proj(projparams)
            dx = projinfo['dx']
            dy = projinfo['dy']
            x = dx*N.indices((ny,nx),'f')[1,:,:]
            x = x - 0.5*N.maximum.reduce(N.ravel(x))
            y = dy*N.indices((ny,nx),'f')[0,:,:]
            y = y - 0.5*N.maximum.reduce(N.ravel(y))
            lons, lats = pj(x,y,inverse=True)
            # set lons,lats to 1.e30 where undefined
            abslons = N.fabs(lons); abslats = N.fabs(lats)
            lons = N.where(abslons < 1.e20, lons, 1.e30)
            lats = N.where(abslats < 1.e20, lats, 1.e30)
        else:
            print '%s not supported' % self.projection[n][ifld]
            return False, False
        return lats.astype('f'), lons.astype('f')

    def getgridinfo(self,n,ifld=0):
        """
 return dictionary with projection grid info.
 currently can handle reg. lat/lon, global gaussian, mercator, stereographic
 and lambert conformal grids.
 
 @param n: the grib message number (starting from 0) of the grid.
 @keyword i: the field number within the specified message (default 0, or
 first field).
 
 @return: C{B{projinfo}}, a python dictionary containing key/value pairs
 describing the map projection and grid size.
        """
        projinfo = {}
        projparams = {}
        earthR = sxn3.codetable[2][self.gdtmpl[n][ifld][0]]
        if _isString(earthR) and (earthR.startswith('Reserved') or earthR=='Missing'):
            raise ValueError,'Shape of earth not given' % repr(earthR)
        if _isString(earthR) and earthR.startswith('Spherical'):
            scaledearthR = self.gdtmpl[n][ifld][2]
            earthRscale = self.gdtmpl[n][ifld][1]
            earthR = math.pow(10,-earthRscale)*scaledearthR
            projinfo['earthR'] = earthR
            projparams['R'] = earthR
            earthRmajor = earthR
            ellipse = False
        elif _isString(earthR) and earthR.startswith('OblateSpheroid'):
            scaledearthRmajor = self.gdtmpl[n][ifld][4]
            earthRmajorscale = self.gdtmpl[n][ifld][3]
            earthRmajor = math.pow(10,-earthRmajorscale)*scaledearthRmajor
            earthRmajor = earthRmajor*1000. # convert to m from km
            scaledearthRminor = self.gdtmpl[n][ifld][6]
            earthRminorscale = self.gdtmpl[n][ifld][5]
            earthRminor = math.pow(10,-earthRminorscale)*scaledearthRminor
            earthRminor = earthRminor*1000. # convert to m from km
            projinfo['earthRminor'] = earthRminor
            projinfo['earthRmajor'] = earthRmajor
            projparams['a'] = earthRmajor
            projparams['b'] = earthRminor
            if earthRminor != earthRmajor: 
                ellipse=True
            else:
                ellipse=False
        elif _isString(earthR) and earthR.startswith('WGS84'):
            projinfo['ellipse'] = 'WGS84'
            projparams['ellps'] = 'WGS84'
            earthRmajor = 6378137.0
            ellipse = True
        elif isinstance(earthR,tuple):
            earthRmajor = earthR[0]
            earthRminor = earthR[1]
            projinfo['earthRminor'] = earthRminor
            projinfo['earthRmajor'] = earthRmajor
            projparams['b'] = earthRminor
            projparams['a'] = earthRmajor
            if earthRminor != earthRmajor: 
                ellipse=True
            else:
                ellipse=False
        else: 
            projinfo['earthR'] = earthR
            projparams['R'] = earthR
            earthRmajor = earthR
            ellipse=False
        if self.gdtnum[n][ifld] == 0: # regular lat/lon grid
            lat1 = self.gdtmpl[n][ifld][11]/1.e6
            lon1 = self.gdtmpl[n][ifld][12]/1.e6
            lat2 = self.gdtmpl[n][ifld][14]/1.e6
            lon2 = self.gdtmpl[n][ifld][15]/1.e6
            delon = self.gdtmpl[n][ifld][16]/1.e6
            delat = self.gdtmpl[n][ifld][17]/1.e6
            if lat1 > lat2: 
                delat = -delat
            if lon1 > lon2:
                delon = -delon
            projinfo['nlons']=self.gdtmpl[n][ifld][7]
            projinfo['nlats']=self.gdtmpl[n][ifld][8]
            projinfo['dlon']=delon
            projinfo['dlat']=delat
        elif self.gdtnum[n][ifld] == 10: # mercator
            nx = self.gdtmpl[n][ifld][7]
            ny = self.gdtmpl[n][ifld][8]
            lat1 = self.gdtmpl[n][ifld][9]/1.e6
            lon1 = self.gdtmpl[n][ifld][10]/1.e6
            lat2 = self.gdtmpl[n][ifld][13]/1.e6
            lon2 = self.gdtmpl[n][ifld][14]/1.e6
            dx = self.gdtmpl[n][ifld][17]
            dy = self.gdtmpl[n][ifld][18]
            projparams['proj'] = 'merc'
            projparams['lat_ts'] = self.gdtmpl[n][ifld][12]/1.e6
            projparams['lon_0'] = 0.5*(lon1+lon2)
            projinfo['standardpar'] = self.gdtmpl[n][ifld][12]/1.e6
            projinfo['centerlon'] = 0.5*(lon1+lon2)
            projinfo['nx'] = nx
            projinfo['ny'] = ny
            projinfo['dx'] = dx
            projinfo['dy'] = dy
            pj = Proj(projparams,lon1,lat1,(nx-1)*dx,(ny-1)*dy,urcrnrislatlon=False)
            projinfo['projparams'] = projparams
        elif self.gdtnum[n][ifld] == 20: # stereographic
            projflag = tobase(2,int(self.gdtmpl[n][ifld][16]))[0]
            nx = self.gdtmpl[n][ifld][7]
            ny = self.gdtmpl[n][ifld][8]
            lat1 = self.gdtmpl[n][ifld][9]/1.e6
            lon1 = self.gdtmpl[n][ifld][10]/1.e6
            projparams['proj'] = 'stere'
            projparams['lat_ts'] = self.gdtmpl[n][ifld][12]/1.e6
            projinfo['standardpar'] = self.gdtmpl[n][ifld][12]/1.e6
            if projflag == '0':
                projparams['lat_0'] = 90
                projinfo['pole'] = 'North'
            elif projflag == '1':
                projparams['lat_0'] = -90
                projinfo['pole'] = 'South'
            else:
                raise ValueError,'Invalid projection center flag = %s' % projflag
            projparams['lon_0'] = self.gdtmpl[n][ifld][13]/1.e6
            projinfo['centerlon'] = self.gdtmpl[n][ifld][13]/1.e6
            dx = self.gdtmpl[n][ifld][14]/1000.
            dy = self.gdtmpl[n][ifld][15]/1000.
            projinfo['nx'] = nx
            projinfo['ny'] = ny
            projinfo['dx'] = dx
            projinfo['dy'] = dy
            pj = Proj(projparams,lon1,lat1,(nx-1)*dx,(ny-1)*dy,urcrnrislatlon=False)
            projinfo['projparams'] = projparams
            lon2 = None; lat2 = None
        elif self.gdtnum[n][ifld] == 30: # lambert conformal
            lat1 = self.gdtmpl[n][ifld][9]/1.e6
            lon1 = self.gdtmpl[n][ifld][10]/1.e6
            nx = self.gdtmpl[n][ifld][7]
            ny = self.gdtmpl[n][ifld][8]
            dx = self.gdtmpl[n][ifld][14]/1000.
            dy = self.gdtmpl[n][ifld][15]/1000.
            projinfo['nx'] = nx
            projinfo['ny'] = ny
            projinfo['dx'] = dx
            projinfo['dy'] = dy
            projparams['proj'] = 'lcc'
            projparams['lat_1'] = self.gdtmpl[n][ifld][18]/1.e6
            projparams['lat_2'] = self.gdtmpl[n][ifld][19]/1.e6
            projparams['lon_0'] = self.gdtmpl[n][ifld][13]/1.e6
            projinfo['standardpar1'] = self.gdtmpl[n][ifld][18]/1.e6
            projinfo['standardpar2'] = self.gdtmpl[n][ifld][19]/1.e6
            projinfo['centerlon'] = self.gdtmpl[n][ifld][13]/1.e6
            lon2 = None; lat2 = None
            pj = Proj(projparams,lon1,lat1,(nx-1)*dx,(ny-1)*dy,urcrnrislatlon=False)
            projinfo['projparams'] = projparams
        elif self.gdtnum[n][ifld] == 40: # gaussian grid (only works for global!)
            nlatsg = self.gdtmpl[n][ifld][8]
            nlats = self.gdtmpl[n][ifld][17]
            if nlats*2 != nlatsg:
                raise ValueError, 'can only handle global gaussian grid'
            nlats = nlatsg
            lat1 = self.gdtmpl[n][ifld][11]/1.e6
            lon1 = self.gdtmpl[n][ifld][12]/1.e6
            lat2 = self.gdtmpl[n][ifld][14]/1.e6
            lon2 = self.gdtmpl[n][ifld][15]/1.e6
            delon = self.gdtmpl[n][ifld][16]/1.e6
            if lon1 > lon2:
                delon = -delon
            lons = N.arange(lon1,lon2+delon,delon)
            # compute gaussian lats (north to south)
            lats = gaussian.lats(nlats)
            if lat1 < lat2:  # reverse them if necessary
                lats = lats[::-1]
            projinfo['nlons']=len(lons)
            projinfo['nlats']=len(lats)
            projinfo['dlon']=delon
            lons,lats = _meshgrid(lons,lats) # make 2-d arrays
        elif self.gdtnum[n][ifld] == 90: # near-sided vertical perspective satellite projection
            lat_0 = self.gdtmpl[n][ifld][9]/1.e6
            lon_0 = self.gdtmpl[n][ifld][10]/1.e6
            h = earthRmajor * (self.gdtmpl[n][ifld][18]/1.e6)
            nx = self.gdtmpl[n][ifld][7]
            ny = self.gdtmpl[n][ifld][8]
            dx = self.gdtmpl[n][ifld][12]
            dy = self.gdtmpl[n][ifld][13]
            projinfo['nx'] = nx
            projinfo['ny'] = ny
            projinfo['centerlon'] = lon_0
            projinfo['centerlat'] = lon_0
            projinfo['camera_altitude'] = h
            lat1 = None
            lat2 = None
            if lat_0 == 0.:
                projparams['proj'] = 'geos'
                projparams['lon_0'] = lon_0
                projparams['lat_0'] = lat_0
                projparams['h'] = h - earthRmajor
                projinfo['dx'] = 2.*earthRmajor/dx
                if ellipse:
                    projinfo['dy'] = 2.*earthRminor/dy
                else:
                    projinfo['dy'] = 2.*earthRmajor/dy
            elif not ellipse:
                projparams['proj'] = 'npers'
                projparams['lon_0'] = lon_0
                projparams['lat_0'] = lat_0
                projparams['h'] = h
                projinfo['dx'] = 2.*earthRmajor/dx
                projinfo['dy'] = 2.*earthRmajor/dy
            else:     
                print '%s only supported for Oblate Spheroids when sub-satellite point is on the equator' % self.projection[n][ifld]
                return False
            projinfo['projparams'] = projparams
        else:
            print '%s not supported' % self.projection[n][ifld]
            return False
        if lat1 != None and lon1 != None:
            projinfo['lat/lon first grid pt']=(lat1,lon1)
        if lat2 != None and lon2 != None:
            projinfo['lat/lon last grid pt']=(lat2,lon2)
        return projinfo

# private methods and functions below here.

    def _getvertlevel(self,n,ifld=0):
        """return vertical coordinate level info"""
        try:
            level1info = sxn4.codetable[5][self.pdtmpl[n][ifld][9]]
            scaledlevel1 = self.pdtmpl[n][ifld][11]
            level1scale = self.pdtmpl[n][ifld][10]
        except:
            scaledlevel1 = None
            level1scale = None
            level1info = ['','']
        if level1scale in [-127,255]: # either of these two values can indicate 'Missing'
            level1scale = None
        if scaledlevel1 in [2*(2**31-1),-(2**31-1)]: # ditto 
            scaledlevel1 = None
        if scaledlevel1 is not None and level1scale is not None:
            level1 = math.pow(10,-level1scale)*scaledlevel1
        else:
            level1 = None
        if len(self.pdtmpl[n][ifld]) >= 12 and self.pdtmpl[n][ifld][12] != 255:
           level2info = sxn4.codetable[5][self.pdtmpl[n][ifld][12]]
           scaledlevel2 = self.pdtmpl[n][ifld][14]
           level2scale = self.pdtmpl[n][ifld][13]
           level2 = math.pow(10,-level2scale)*scaledlevel2
           return level1,level1info[1],level1info[0],level2,level2info[1],level2info[0]
        else:
           return level1,level1info[1],level1info[0]

    def _getdate(self,n):
        """return yyyy,mm,dd,min,ss from section 1"""
        yyyy=self.idsect[n][5]
        mm=self.idsect[n][6]
        dd=self.idsect[n][7]
        hh=self.idsect[n][8]
        min=self.idsect[n][9]
        ss=self.idsect[n][10]
        return yyyy,mm,dd,hh,min,ss

    def _getfcsttime(self,n,ifld=0):
        """return forecast time, units"""
        # assumes forecast time is eighth value in 
        # all product defn templates.
        time = self.pdtmpl[n][ifld][8]
        units = sxn4.codetable[4][self.pdtmpl[n][ifld][7]]
        if self.pdtnum[n][ifld] == 8:
            stattype = self.pdtmpl[n][ifld][23]
            if stattype == 255:
                stattype = 'Period'
            else:
                stattype = sxn4.codetable[10][stattype]
            timeintervalunits = self.pdtmpl[n][ifld][25]
            timeintervalunits = sxn4.codetable[4][timeintervalunits]
            timeintervallen = self.pdtmpl[n][ifld][26]
            if timeintervalunits == 10:
                timelintervallen = timeintervallen*3
            elif timeintervalunits == 11:
                timeintervallen = timeintervallen*6
            elif timeintervalunits == 12:
                timeintervallen = timeintervallen*12
            return time,units,timeintervallen,timeintervalunits,stattype
        else:
            return time,units

    def _getensinfo(self,n,ifld):
        """return ensemble info (from pdts 4.1, 4.2, 4.11, 4.12)"""
        if self.pdtnum[n][ifld] in [1,11]:
            enstype = sxn4.codetable[6][self.pdtmpl[n][ifld][15]]
            pertnum = self.pdtmpl[n][ifld][16]
            nmembers = self.pdtmpl[n][ifld][17]
            return enstype,pertnum,nmembers
        elif self.pdtnum[n][ifld] in [2,12]:
            enstype = sxn4.codetable[7][self.pdtmpl[n][ifld][15]]
            nmembers = self.pdtmpl[n][ifld][16]
            return enstype,None,nmembers
        else:
            print 'not an ensemble product'
            return None,None,None

    def _getdiscipline(self,n):
        """return descipline"""
        discipline = self.discipline[n]
        return sxn0.codetable[discipline] 

    def _getpdt(self,n,ifld=0):
        """return name of product definition template"""
        return sxn4.codetable[0][self.pdtnum[n][ifld]]

    def _getparamcat(self,n,ifld=0):
        """return parameter category description"""
        discipline = self.discipline[n][ifld]
        paramcat = self.pdtmpl[n][ifld][0]
        return sxn4.codetable[1][discipline][paramcat]

    def _getparam(self,n,ifld=0):
        """return parameter name, units"""
        discipline = self.discipline[n]
        # assumes parameter category and parameter number are first two in 
        # all product defn templates.
        paramcat = self.pdtmpl[n][ifld][0]
        try:
            sxn4.codetable[2][discipline][paramcat].has_key(self.pdtmpl[n][ifld][1]) 
            return sxn4.codetable[2][discipline][paramcat][self.pdtmpl[n][ifld][1]]
        except:
            return 'Unknown',''

def _unpack1(gribmsg,pos):
    """unpack section 1 given starting point in bytes
    used to test pyrex interface to g2_unpack1"""
    idsect = []
    pos = pos + 5
    idsect.append(struct.unpack('>h',gribmsg[pos:pos+2])[0])
    pos = pos + 2
    idsect.append(struct.unpack('>h',gribmsg[pos:pos+2])[0])
    pos = pos + 2
    idsect.append(struct.unpack('>B',gribmsg[pos])[0])
    pos = pos + 1
    idsect.append(struct.unpack('>B',gribmsg[pos])[0])
    pos = pos + 1
    idsect.append(struct.unpack('>B',gribmsg[pos])[0])
    pos = pos + 1
    idsect.append(struct.unpack('>h',gribmsg[pos:pos+2])[0])
    pos = pos + 2
    idsect.append(struct.unpack('>B',gribmsg[pos])[0])
    pos = pos + 1
    idsect.append(struct.unpack('>B',gribmsg[pos])[0])
    pos = pos + 1
    idsect.append(struct.unpack('>B',gribmsg[pos])[0])
    pos = pos + 1
    idsect.append(struct.unpack('>B',gribmsg[pos])[0])
    pos = pos + 1
    idsect.append(struct.unpack('>B',gribmsg[pos])[0])
    pos = pos + 1
    idsect.append(struct.unpack('>B',gribmsg[pos])[0])
    pos = pos + 1
    idsect.append(struct.unpack('>B',gribmsg[pos])[0])
    pos = pos + 1
    return N.array(idsect,'i'),pos

def _repeatlast(numfields,listin):
    """repeat last item in listin, until len(listin) = numfields"""
    if len(listin) < numfields:
        last = listin[-1]
        for n in range(len(listin),numfields):
            listin.append(last)
    return listin

def _isString(string):
    """Test if string is a string like object if not return 0 """
    try: string + ''
    except: return 0
    else: return 1

def _meshgrid(x, y):
    """
    For vectors x, y with lengths Nx=len(x) and Ny=len(y), return X, Y
    where X and Y are (Ny, Nx) shaped arrays with the elements of x
    and y repeated to fill the matrix
    """
    x = N.array(x)
    y = N.array(y)
    numRows, numCols = len(y), len(x)  # yes, reversed
    x.shape = 1, numCols
    X = N.repeat(x, numRows, 0)
    y.shape = numRows,1
    Y = N.repeat(y, numCols, 1)
    return X, Y

class Grib2Encode:
    """
 Class for encoding data into a GRIB2 message.
  - Creating a class instance (L{__init__}) initializes the message and adds 
    sections 0 and 1 (the indicator and identification sections), 
  - method L{addgrid} adds a grid definition (section 3) to the messsage.
  - method L{addfield} adds sections 4-7 to the message (the product
    definition, data representation, bitmap and data sections).
  - method L{end} adds the end section (section 8) and terminates the message.


 A GRIB Edition 2 message is a machine independent format for storing
 one or more gridded data fields.  Each GRIB2 message consists of the 
 following sections:
  - SECTION 0: Indicator Section - only one per message
  - SECTION 1: Identification Section - only one per message
  - SECTION 2: (Local Use Section) - optional                          
  - SECTION 3: Grid Definition Section                                
  - SECTION 4: Product Definition Section              
  - SECTION 5: Data Representation Section   
  - SECTION 6: Bit-map Section               
  - SECTION 7: Data Section                  
  - SECTION 8: End Section                   

 Sequences of GRIB sections 2 to 7, 3 to 7, or sections 4 to 7 may be repeated
 within a single GRIB message.  All sections within such repeated sequences
 must be present and shall appear in the numerical order noted above.
 Unrepeated sections remain in effect until redefined.

 Note:  Reading/writing section 2 (the 'local use section') is
 not yet supported.

 @ivar msg: A binary string containing the GRIB2 message.
 After the message has been terminated by calling
 the L{end} method, this string can be written to a file.
    """

    def __init__(self, discipline, idsect):
        """
 create a Grib2Enecode class instance given the GRIB2 discipline
 parameter and the identification section (sections 0 and 1).

 The GRIB2 message is stored as a binary string in instance variable L{msg}.

 L{addgrid}, L{addfield} and L{end} class methods must be called to complete
 the GRIB2 message.
 
 @param discipline:  Discipline or GRIB Master Table Number (Code Table 0.0).
 (0 for meteorlogical, 1 for hydrological, 2 for land surface, 3 for space,
 10 for oceanographic products).

 @param idsect:  Sequence containing identification section (section 1).
  - idsect[0]=Id of orginating centre (Common Code Table C-1) 
  - idsect[1]=Id of orginating sub-centre (local table) 
  - idsect[2]=GRIB Master Tables Version Number (Code Table 1.0) 
  - idsect[3]=GRIB Local Tables Version Number (Code Table 1.1) 
  - idsect[4]=Significance of Reference Time (Code Table 1.2) 
  - idsect[5]=Reference Time - Year (4 digits) 
  - idsect[6]=Reference Time - Month 
  - idsect[7]=Reference Time - Day 
  - idsect[8]=Reference Time - Hour 
  - idsect[9]=Reference Time - Minute 
  - idsect[10]=Reference Time - Second 
  - idsect[11]=Production status of data (Code Table 1.3) 
  - idsect[12]=Type of processed data (Code Table 1.4) 
        """
        self.msg,msglen=g2lib.grib2_create(N.array([discipline,2],'i'),N.array(idsect,'i'))

    def addgrid(self,gdsinfo,gdtmpl,deflist=None):
        """
 Add a grid definition section (section 3) to the GRIB2 message.

 @param gdsinfo: Sequence containing information needed for the grid definition section.
  - gdsinfo[0] = Source of grid definition (see Code Table 3.0) 
  - gdsinfo[1] = Number of grid points in the defined grid.
  - gdsinfo[2] = Number of octets needed for each additional grid points defn.
    Used to define number of points in each row for non-reg grids (=0 for 
    regular grid).
  - gdsinfo[3] = Interp. of list for optional points defn (Code Table 3.11)
  - gdsinfo[4] = Grid Definition Template Number (Code Table 3.1)

 @param gdtmpl: Contains the data values for the specified Grid Definition 
 Template ( NN=gds[4] ).  Each element of this integer  
 array contains an entry (in the order specified) of Grid 
 Definition Template 3.NN 

 @param deflist: (Used if gds[2] != 0)  Sequence containing the
 number of grid points contained in each row (or column) 
 of a non-regular grid.
        """
        if deflist is not None:
            dflist = N.array(deflist,'i')
        else:
            dflist = None
        self.msg,msglen=g2lib.grib2_addgrid(self.msg,N.array(gdsinfo,'i'),N.array(gdtmpl,'i'),dflist)

    def addfield(self,pdtnum,pdtmpl,drtnum,drtmpl,field,coordlist=None,bitmapflag=255,bitmap=None):
        """
 Add a product definition section, data representation section,
 bitmap section and data section to the GRIB2 message (sections 4-7).

 @param pdtnum: Product Definition Template Number (see Code Table 4.0)

 @param pdtmpl: Sequence with the data values for the specified Product Definition
 Template (N=pdtnum).  Each element of this integer 
 array contains an entry (in the order specified) of Product
 Definition Template 4.N

 @param drtnum: Data Representation Template Number (see Code Table 5.0).

 @param drtmpl: Sequence with the data values for the specified Data Representation
 Template (N=drtnum).  Each element of this integer 
 array contains an entry (in the order specified) of Data
 Representation Template 5.N
 Note that some values in this template (eg. reference
 values, number of bits, etc...) may be changed by the
 data packing algorithms.
 Use this to specify scaling factors and order of
 spatial differencing, if desired.

 @param field:  float32 numpy array of data points to pack.

 @param coordlist: Sequence containing floating point values intended to document
 the vertical discretization with model data
 on hybrid coordinate vertical levels. Default None.

 @param bitmapflag: Bitmap indicator (see Code Table 6.0) Default 255.
  - 0 = bitmap applies and is included in Section 6.
  - 1-253 = Predefined bitmap applies
  - 254 = Previously defined bitmap applies to this field
    (it still must be provided, it just won't
    be encoded into the message again)
  - 255 = Bit map does not apply to this product.

 @param bitmap: int32 numpy array containing bitmap to be added 
 (if bitmapflag=0 or 254). Default None.
        """
        if (drtnum == 40 or drtnum == 40000) and not jpeg2000_support:
            raise ValueError, 'Sorry, but the grib2 module was not compiled with support for JPEG2000 encoding'
        if (drtnum == 41 or drtnum == 40010) and not png_support:
            raise ValueError, 'Sorry, but the grib2 module was not compiled with support for PNG encoding'
        fld = N.array(field.astype('f'),'f')
        if bitmap is not None:
            bmap = N.ravel(N.array(bitmap,'i'))
        else:
            bmap = None
        if coordlist is not None:
            crdlist = N.array(coordlist,'f')
        else:
            crdlist = None
        self.msg,msglen=g2lib.grib2_addfield(self.msg,pdtnum,N.array(pdtmpl,'i'),crdlist,drtnum,N.array(drtmpl,'i'),N.ravel(fld),bitmapflag,bmap)

    def end(self):
        """
 Add an end section (section 8) to the GRIB2 message.
 A GRIB2 message is not complete without an end section.
 Once an end section is added, the GRIB2 message can be
 output to a file.
        """
        self.msg,msglen=g2lib.grib2_end(self.msg)
